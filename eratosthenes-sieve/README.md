Sieve of Eratosthenes
=====================

Wikipedia link: [Sieve of Eratosthenes](Sieve of Eratosthenes)

The **Sieve of Eratosthenes** is an algorithm for finding all prime numbers
up to a certain limit, which works as follows:

* Decide up to what number you want calculate the primes. Call this number **N**.
* List all numbers from 1 to **N**.
* Cross out 1 as not being a prime.
* Repeat the following step, until all primes up to **N** have been found:
   * Pick the first number not yet crossed out.
   * This number is the next prime that you have found. Call this number **P**.
   * Cross out all multiples of **P** greater than **P** itself.

There are various refinements of this algorithm which improve efficiency. Two which
I have used in the accompanying code are:

* The first multiple of **P** that you need to cross out is **P**<sup>2</sup>, because
every smaller multiple of **P** must also be a multiple of some prime smaller than **P**,
and must therefore already have been crossed out.
* Once you get to **P** where **P**<sup>2</sup> is greater than **N**, you know that you
don't have to check any multiples at all -- you can just read off the remaining numbers
not crossed out as primes.

Code Notes
----------

The sieve is most easily described as a process of "crossing out" numbers. In practice,
in a program, one creates an array of booleans, starting as all **true** values, and
"crossing out" a number **n** is implemented by setting the array value indexed by **n** to **false**.

As in most other programming languages, array indexes in Python are zero-based. So to
keep things simple, I include 0 in the list of numbers to cross out, and start by crossing out
0 and 1.

The sieve is implemented as an object of the class **SieveOfEratosthenes** which is initialised with the size
(i.e. **N** as defined above). The primes are generated by calling method **generatePrimes**
on the sieve object. **generatePrimes** fully resets the state of the sieve each time, so it can be
called any number of times.

